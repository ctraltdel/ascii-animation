<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="ascii-animation-keyframe.html">
<!--
An element to provide a way to animate ascii text. Animation is keyframe based. 

A sequence of keyframes are used with a selector property indicating the frame should display when the duration is that % out of 100.

Example:

    <ascii-animation duration="1" autoplay>
      <ascii-animation-keyframe name="smiley" selector="0">:)</ascii-animation-keyframe>
      <ascii-animation-keyframe name="meh" selector="50">:|</ascii-animation-keyframe>
      <ascii-animation-keyframe name="frownie" selector="100">:(</ascii-animation-keyframe>
    </ascii-animation>

@demo demo/index.html
@hero hero.svg
-->

<dom-module id="ascii-animation">
  <template>
    <style>
      :host {
        display: block;
        box-sizing: border-box;
      }
    </style>
    <div id="ascii-view">
      <div id="ascii-content">[[_renderedText]]</div>
    </div>
    <div id="keyframe-content" hidden>
      <content></content>
    </div>
  </template>

  <script>
    /* @typedef {Object} Keyframe
     *   @property {number} selector - 0 to 100 percentage of animation where keyframe is shown.
     *   @property {string} name - name of frame for organizational reasons
     *   @property {stirng} display - ascii text to be displayed in frame.
     */
    Polymer({
      is: 'ascii-animation',

      properties: {
        /**
         * `autoplay` indicates that the element should begin animating immediately 
         * when attached.
         */
        autoplay: Boolean,
        /**
         * `loop` indicates that playback should restart when it reaches the end.
         */
        loop: Boolean,
        /**
         * `reverse` indicates that playback should be backwards.
         */
        reverse: {
          type: Boolean,
          notify: true,
          observer: '_directionChanged'
        },
        /** 
         * `bounce` indicates playback should alternate between forwards and reverse.
         * can be used a long with loop.
         */
        bounce: Boolean,
        /**
         * `running` is true when the animation is currently playing.
         */
        running: {
          type: Boolean,
          notify: true,
          value: false
        },
        /**
         * array of keyframes either from `<ascii-animation-keyframe>` elements in the content
         * or can be set programmatically.
         * @type Array.{Keyframe}
         */
        keyframes: {
          type: Array,
          notify: true,
          value: function () {
            // this needs to get the keyframes from the content.
            return [];
          }
        },
        /**
         * 0-100 starting point of animation, default is 0
         */
        inPoint: {
          type: Number,
          value: 0
        },
        /**
         * 0-100 ending point of animation
         */
        outPoint: {
          type: Number,
          value: 100
        },
        // private
        /**
         * `_renderedText` contains all the frames rendered into one string with proper padding for rows and cols.
         */
        _renderedText: {
          type: String,
          notify: true
        },
        /**
         * `_charCols` stores the number of columns in the longest line of any keyframe.
         * all lines in all frames will be padded to this value when generating _renderedText
         */
        _charCols: {
          type: Number,
          notify: true,
          value: 0
        },
        /**
         * `_charRows` stores the highest number of rows in any keyframe.
         * all frames are then padded to this value when generating _renderedText
         */
        _charRows: {
          type: Number,
          notify: true,
          value: 0
        },
        /**
         * `_keyFramePositions` is a simplified array of all the selectors in the provided keyframes
         * example: if there are keyframes for 0, 33, 66, and 100, the array will be
         * [0,33,66,100]
         */
        _keyFramePositions: {
          type: Array
        },
        /**
         * `_handle` is the current async handle so pause and stop can cancel it.
         */
        _handle: {
          type: Object
        },
        /**
         * `_ready` set after ready event fires
         */
        _ready: Boolean,
        /**
         * `_attached` set after attached event fires
         */
        _attached: Boolean,
        /**
         * `_percent` is the current position of the play head from 0 - 100
         */
        _percent: {
          type: Number,
          notify: true,
          observer: '_percentChanged'
        }
      },
      observers: ['_keyFramesChanged(keyframes.*)'],
      // Element Lifecycle

      ready: function () {
        // `ready` is called after all elements have been configured, but
        // propagates bottom-up. This element's children are ready, but parents
        // are not.
        //
        // This is the point where you should make modifications to the DOM (when
        // necessary), or kick off any processes the element wants to perform.
        this._ready = true;
      },

      attached: function () {
        // `attached` fires once the element and its parents have been inserted
        // into a document. This is where keyframes are populated from the element's content
        // if they are already defined the ones in content will be pushed to the end of the array.
        // get keyframes from content        
        var keyFrames = this.querySelectorAll('ascii-animation-keyframe');
        //var keyFrames = Polymer.dom(this).getEffectiveChildren(); ?
        // vars for manual notification
        var startIndex = keyFrames.length != undefined ? keyFrames.length + 1 : 0;
        var addedCount = 0;
        for (var k = 0; k < keyFrames.length; k++) {
          var kf = {
            "name": keyFrames[k].name,
            "selector": keyFrames[k].selector,
            "display": keyFrames[k].display
          };
          this.keyframes.push(kf);
        }
        this._attached = true;
        // this should cause the the _keyFramesChanged observer to fire properly.
        this.notifySplices('keyframes', [{
          "index": startIndex,
          "removed": [],
          "addedCount": addedCount,
          "object": this.keyframes,
          "type": 'splice'
           }]);
      },


      detached: function () {
        // The analog to `attached`, `detached` fires when the element has been
        // removed from a document.
        //
        // Use this to clean up anything you did in `attached`.
        this._attached = false;
      },

      // Element Behavior
      /**
       * Runs the animation from the current `_percent` position.
       */
      play: function () {
        this.running = true;
      },
      /**
       * Sets the running state to false but keeps position
       */
      pause: function () {
        this.cancelAsync(this._handle);
        this.running = false;
      },
      /**
       * Pauses and then sets the animation back to beginning (`inPoint`)
       */
      stop: function () {
        this.pause();
        this._percent = this.inPoint;
      },
      /** 
       * Sets animation `_percert` back to beginning (`inPoint`), does not affect `running` state
       */
      first: function () {
        this._percent = this.inPoint;
      },
      /**
       * Sets the animation `_percent` to the end (`outPoint`), does not affect `running` state
       */
      last: function () {
        this._percent = this.outPoint;
      },
      /** 
       * Moves `_percent` position to the next keyframe
       */
      skipForward: function () {},
      /**
       * Moves `_percent` position to the previous keyframe
       */
      skipBack: function () {},
      /**
       * `_percent` observer, meaning the position in the animation changed so we need
       * to update the frame (maybe)
       */
      _percentChanged: function (newVal, oldVal) {

      },
      /**
       * swaps `inPoint` and `outPoint` when the value of reverse is set.
       * sanity checks direction in case it gets called at a weird time, like from 
       * undefined to true.
       */
      _directionChanged: function (newVal, oldVal) {
        var oldIn = this.inPoint;
        var oldOut = this.outPoint;
        // sanity check before swapping
        // if reversed then inpoint > outpoint or not reversed and inpoint < outpoint
        if ((newVal && oldOut > oldIn) || (!newVal && oldOut < oldIn)) {
          this.set('inPoint', oldOut);
          this.set('outPoint', oldIn);
        }
      },
      /**
       * Updates `_renderedText` when keyframe array changes.
       * Populates `_keyFramePositons`
       * Then sets `_charCols` and `_charRows` and then ascii-view dimensions
       */
      _keyFramesChanged: function (changeRecord) {
        // abort for 0 keyframes.
        if (this.keyframes == null || this.keyframes.length < 1 || !this._attached) {
          return;
        }
        // for each keyframe:        
        var maxWidth = 0;
        var maxLines = 0;
        var keyFrames = this.keyframes;
        this._keyFramePositions = [];
        this._lastFramePercent = 0;
        var frames = keyFrames.length;

        // first loop gets dimensions of everything.
        for (var k = 0; k < keyFrames.length; k++) {
          // split each frame content into lines
          if (keyFrames == undefined || keyFrames[k].selector == undefined || keyFrames[k].display == undefined) {
            if (console.error) {
              console.error('Error: render aborted due to invalid keyframe ' + k + ' ' + JSON.stringify(keyFrames[k]));
            }
            this._renderedText = '';
            return;
          }
          var lines = keyFrames[k].display.split(/\n/);
          this._keyFramePositions.push(keyFrames[k].selector);
          // grab the number of lines in the longest element.
          if (maxLines < lines.length) {
            maxLines = lines.length;
          }
          // grab the number of chars in the longest line.
          for (var l = 0; l < lines.length; l++) {
            // find maximum width
            if (maxWidth < lines[l].length) {
              maxWidth = lines[l].length;
            }
          }
        }
        var frames = [];
        for (var k = 0; k < keyFrames.length; k++) {
          var frame = [];
          var lines = keyFrames[k].display.split(/\n/);
          for (var l = 0; l < lines.length; l++) {
            // add each line with padding to frame.
            frame.push(this._rightPad(lines[l], ' ', maxWidth));
          }
          // pad with blank lines
          var blankLinesNeeded = maxLines - frame.length;
          for (var b = 0; b < blankLinesNeeded; b++) {
            frame.push(this._rightPad('', ' ', maxWidth));
          }
          frames.push(frame);
        }
        var renderBuffer = '';
        // now render the text into one continuous block by line with a fixed width.
        for (var l = 0; l < lines.length; l++) {
          for (var f = 0; f < frames.length; f++) {
            renderBuffer += frames[f][l];
          }
          renderBuffer += "\n";
        }
        this.set('_renderedText', renderBuffer);
        this._charCols = maxWidth;
        this._charRows = maxLines;
        this.$['ascii-view'].style.width = this._charCols + 'ch';
        this.$['ascii-view'].style.height;
        this._charRows + 'ch';
      },
      /** 
       * Utility function used for text rendering. Not a node package.
       * shoutout to: https://eureka.ykyuen.info/2011/08/23/javascript-leftright-pad-a-string/
       */
      _rightPad: function (s, c, n) {
        if (!s || !c || s.length >= n) {
          return s;
        }
        var max = (n - s.length) / c.length;
        for (var i = 0; i < max; i++) {
          s += c;
        }
        return s;
      }
    });
  </script>
</dom-module>